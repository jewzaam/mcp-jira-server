# flake8: noqa: E501
from __future__ import annotations

"""MCP JIRA Server

A read-only Model Context Protocol server that provides tools for:
1. Searching JIRA using simple JQL queries or plain text.
2. Fetching a single JIRA issue by key.
3. Returning a hint describing the expected JIRA issue identifier format.

The implementation is intentionally lightweight and builds on the existing
`jira_extractor.client.JiraClient` that already handles authentication and
basic REST interactions.

Transport: stdio (recommended for local development)
Dependencies:
  * mcp[cli]      – FastMCP implementation and CLI helpers
  * requests      – Already required by jira_extractor

Generated by: Cursor (Claude)
"""

from typing import List, Dict, Any, Optional
import asyncio
import logging
from urllib.parse import urljoin

from pydantic import BaseModel, Field
from cachetools import TTLCache

from .config import load_config, ConfigError

# Default TTL for field discovery cache (1 hour)
DEFAULT_FIELD_CACHE_TTL = 3600

try:
    from mcp.server.fastmcp import FastMCP
    from mcp.types import ToolAnnotations
except ImportError as exc:  # pragma: no cover – avoids breaking tests when mcp missing
    raise SystemExit(
        "The `mcp` package is required to run the MCP JIRA server.\n"
        "Install dependencies first:  pip install -r requirements.txt"
    ) from exc

from jira_extractor.client import JiraClient


###############################################################################
# Data models returned by tools                                                #
###############################################################################

class IssueSummary(BaseModel):
    """Minimal representation of a JIRA issue suitable for search results."""

    key: str = Field(..., title="JIRA issue key", examples=["ABC-123"])
    summary: str = Field(..., title="Issue summary/title")
    status: str = Field(..., title="Status name", examples=["In Progress"])
    url: str = Field(..., title="Direct URL to the issue in the browser")

    model_config = {
        "title": "IssueSummary",
        "extra": "ignore",
    }


class IssueDetails(BaseModel):
    """Subset of fields from the full JIRA issue useful for conversational use.

    The *raw* field allows callers to access the complete response in case they
    need additional data not exposed explicitly.
    """

    key: str = Field(..., title="JIRA issue key")
    summary: str = Field(..., title="Summary/title of the issue")
    description: Optional[str] = Field(None, title="Issue description")
    status: str = Field(..., title="Workflow status name")
    raw: Dict[str, Any] = Field(..., title="Full unmodified JIRA API response")

    model_config = {
        "title": "IssueDetails",
        "extra": "ignore",
    }


class ProjectSummary(BaseModel):
    """Basic information about a JIRA project."""
    
    key: str = Field(..., title="Project key", examples=["PROJ"])
    name: str = Field(..., title="Project name")
    project_type: str = Field(..., title="Project type", examples=["software"])
    lead: Optional[str] = Field(None, title="Project lead username")
    url: str = Field(..., title="Direct URL to the project")

    model_config = {
        "title": "ProjectSummary",
        "extra": "ignore",
    }


class ProjectDetails(BaseModel):
    """Detailed information about a JIRA project."""
    
    key: str = Field(..., title="Project key")
    name: str = Field(..., title="Project name")
    description: Optional[str] = Field(None, title="Project description")
    project_type: str = Field(..., title="Project type")
    lead: Optional[str] = Field(None, title="Project lead username")
    url: str = Field(..., title="Direct URL to the project")
    raw: Dict[str, Any] = Field(..., title="Full unmodified JIRA API response")

    model_config = {
        "title": "ProjectDetails",
        "extra": "ignore",
    }


class FieldInfo(BaseModel):
    """Information about a JIRA field."""
    
    id: str = Field(..., title="Field ID")
    name: str = Field(..., title="Field name")
    custom: bool = Field(..., title="Whether this is a custom field")
    schema_type: Optional[str] = Field(None, title="Field data type")
    
    model_config = {
        "title": "FieldInfo", 
        "extra": "ignore",
    }


class IssueType(BaseModel):
    """Information about a JIRA issue type."""
    
    id: str = Field(..., title="Issue type ID")
    name: str = Field(..., title="Issue type name", examples=["Bug", "Story"])
    description: Optional[str] = Field(None, title="Issue type description")
    subtask: bool = Field(..., title="Whether this is a subtask type")
    
    model_config = {
        "title": "IssueType",
        "extra": "ignore",
    }


class StatusInfo(BaseModel):
    """Information about a JIRA status."""
    
    id: str = Field(..., title="Status ID")
    name: str = Field(..., title="Status name", examples=["Open", "In Progress"])
    description: Optional[str] = Field(None, title="Status description")
    category: Optional[str] = Field(None, title="Status category", examples=["To Do", "In Progress", "Done"])
    
    model_config = {
        "title": "StatusInfo",
        "extra": "ignore",
    }


class Priority(BaseModel):
    """Information about a JIRA priority."""
    
    id: str = Field(..., title="Priority ID")
    name: str = Field(..., title="Priority name", examples=["High", "Medium", "Low"])
    description: Optional[str] = Field(None, title="Priority description")
    
    model_config = {
        "title": "Priority",
        "extra": "ignore",
    }


class UserInfo(BaseModel):
    """Information about a JIRA user."""
    
    username: str = Field(..., title="Username")
    display_name: str = Field(..., title="Display name")
    email: Optional[str] = Field(None, title="Email address")
    active: bool = Field(..., title="Whether user is active")
    
    model_config = {
        "title": "UserInfo",
        "extra": "ignore",
    }


class Comment(BaseModel):
    """Information about a JIRA issue comment."""
    
    id: str = Field(..., title="Comment ID")
    author: str = Field(..., title="Comment author username")
    body: str = Field(..., title="Comment text")
    created: str = Field(..., title="Creation timestamp")
    updated: Optional[str] = Field(None, title="Last update timestamp")
    
    model_config = {
        "title": "Comment",
        "extra": "ignore",
    }


class Transition(BaseModel):
    """Information about an available workflow transition."""
    
    id: str = Field(..., title="Transition ID")
    name: str = Field(..., title="Transition name")
    to_status: str = Field(..., title="Target status name")
    
    model_config = {
        "title": "Transition",
        "extra": "ignore",
    }


class IssueLink(BaseModel):
    """Information about a link between JIRA issues."""
    
    issue_key: str = Field(..., title="Linked issue key")
    link_type: str = Field(..., title="Link type name")
    direction: str = Field(..., title="Link direction", examples=["inward", "outward"])
    relationship: str = Field(..., title="Relationship description", examples=["blocks", "is blocked by"])
    
    model_config = {
        "title": "IssueLink",
        "extra": "ignore",
    }


class IssueRelationships(BaseModel):
    """Complete relationship information for a JIRA issue."""
    
    issue_key: str = Field(..., title="Source issue key")
    parent: Optional[str] = Field(None, title="Parent issue key (for subtasks)")
    subtasks: List[str] = Field(default_factory=list, title="List of subtask keys")
    issue_links: List[IssueLink] = Field(default_factory=list, title="Issue links")
    remote_links_count: int = Field(0, title="Number of remote links")
    
    model_config = {
        "title": "IssueRelationships",
        "extra": "ignore",
    }




class ParentInfo(BaseModel):
    """Information about an issue's immediate parent."""
    
    issue_key: str = Field(..., title="Child issue key")
    parent_key: Optional[str] = Field(None, title="Parent issue key (None if no parent)")
    parent_summary: Optional[str] = Field(None, title="Parent issue summary")
    parent_type: Optional[str] = Field(None, title="Type of parent relationship")
    
    model_config = {
        "title": "ParentInfo",
        "extra": "ignore",
    }


class AncestorTree(BaseModel):
    """Tree structure of issue ancestors."""
    
    root_issue: str = Field(..., title="Starting issue key")
    max_depth: int = Field(..., title="Maximum traversal depth")
    total_ancestors: int = Field(..., title="Total number of ancestors found")
    ancestors: List[IssueSummary] = Field(..., title="All ancestor issues")
    traversal_order: List[Dict[str, Any]] = Field(..., title="Order ancestors were discovered")
    
    model_config = {
        "title": "AncestorTree",
        "extra": "ignore",
    }


###############################################################################
# Tools implementation                                                         #
###############################################################################

class JiraTools:
    """Collection of MCP *tools* backed by :class:`JiraClient`."""

    def __init__(self, client: JiraClient, field_cache_ttl: int = DEFAULT_FIELD_CACHE_TTL):
        self._client = client
        self._logger = logging.getLogger(__name__).getChild("JiraTools")
        self._field_cache = TTLCache(maxsize=100, ttl=field_cache_ttl)

    # ---------------------------------------------------------------------
    # Search
    # ---------------------------------------------------------------------
    async def search_issues(self, query: str, max_results: int = 25) -> List[IssueSummary]:
        """Search the JIRA instance for issues.

        The *query* parameter accepts either full JQL (e.g. `project = ABC AND text ~ "foo"`) or a
        free-text term (e.g. `RFE-7877`).  If the query does **not** contain a space or an `=` sign
        we treat it as a simple free-text search using the *summary* field.
        """

        # Heuristic – detect if the user likely provided JQL. Very naive but good enough for hinting.
        is_jql = "=" in query or "order by" in query.lower() or " AND " in query or " OR " in query

        if is_jql:
            jql = query
        else:
            # Use summary ~ "..." for simple search to avoid full-text side-effects.
            term = query.replace("\"", "\\\"")
            jql = f'summary ~ "{term}"'

        url = urljoin(self._client.api_base, "search")
        params = {
            "jql": jql,
            "fields": "key,summary,status",
            "maxResults": max(1, min(max_results, 100)),
        }

        self._logger.info("JIRA search: %s", jql)
        response = self._client._make_api_request(url, params=params, resource_name="search results")

        summaries: List[IssueSummary] = []
        for issue in response.get("issues", []):
            key = issue.get("key")
            fields = issue.get("fields", {})
            summary = fields.get("summary", "")
            status = fields.get("status", {}).get("name", "")
            summaries.append(
                IssueSummary(
                    key=key,
                    summary=summary,
                    status=status,
                    url=f"{self._client.base_url}/browse/{key}",
                )
            )

        return summaries

    # ------------------------------------------------------------------
    # Get single issue
    # ------------------------------------------------------------------
    async def get_issue(self, key: str, expand: Optional[str] = None) -> IssueDetails:
        """Fetch a single JIRA issue by key."""
        issue = self._client.get_issue(key, expand=expand)
        fields = issue.get("fields", {})
        details = IssueDetails(
            key=issue.get("key"),
            summary=fields.get("summary", ""),
            description=fields.get("description"),
            status=fields.get("status", {}).get("name", ""),
            raw=issue,
        )
        return details

    # ------------------------------------------------------------------
    # Identifier hint
    # ------------------------------------------------------------------
    async def identifier_hint(self) -> str:
        """Return a short description of valid JIRA identifier structure."""
        return (
            "JIRA issue identifiers follow the pattern `<PROJECT>-<NUMBER>`, where `<PROJECT>` "
            "is an uppercase project key consisting of letters (e.g., `RFE`) and `<NUMBER>` is "
            "a positive integer (e.g., `7877`).  Example: `RFE-7877`."
        )

    # ------------------------------------------------------------------
    # Field discovery for parent relationships
    # ------------------------------------------------------------------
    def _get_parent_fields_for_issue(self, issue_key: str, project: str, issue_type: str) -> List[str]:
        """Discover parent fields for a specific project:issue_type combination."""
        cache_key = f"{project}::{issue_type}"
        
        # Check cache first
        try:
            cached_fields = self._field_cache[cache_key]
            self._logger.debug(f"Using cached parent fields for {cache_key}: {cached_fields}")
            return cached_fields
        except KeyError:
            pass  # Cache miss
        
        # Query editmeta for this issue to discover parent fields
        parent_fields = []
        try:
            url = urljoin(self._client.api_base, f"issue/{issue_key}/editmeta")
            response = self._client._make_api_request(url, resource_name="editmeta")
            
            fields = response.get("fields", {})
            for field_id, field_info in fields.items():
                schema = field_info.get("schema", {})
                custom_type = schema.get("custom", "")
                
                # Identify parent-type fields by their schema custom type
                if custom_type in [
                    "com.pyxis.greenhopper.jira:gh-epic-link",      # Epic Link fields
                    "com.atlassian.jpo:jpo-custom-field-parent"     # Parent Link fields
                ]:
                    parent_fields.append(field_id)
                    self._logger.debug(f"Found parent field {field_id} ({field_info.get('name', 'Unknown')}) for {cache_key}")
            
            # Cache the discovered fields
            self._field_cache[cache_key] = parent_fields
            self._logger.debug(f"Cached parent fields for {cache_key}: {parent_fields}")
            
        except Exception as e:
            self._logger.warning(f"Failed to discover parent fields for {cache_key}: {e}")
            # Return fallback field IDs based on our known patterns
            parent_fields = ["customfield_12311140", "customfield_12313140"]
            
        return parent_fields

    # ------------------------------------------------------------------
    # Issue relationships
    # ------------------------------------------------------------------
    async def get_issue_relationships(self, issue_key: str) -> IssueRelationships:
        """Get all relationships for a specific JIRA issue."""
        issue_data = self._client.get_issue(issue_key, expand="issuelinks")
        fields = issue_data.get("fields", {})
        
        # Extract parent (for subtasks)
        parent = None
        parent_data = fields.get("parent")
        if parent_data:
            parent = parent_data.get("key")
        
        # Extract subtasks
        subtasks = []
        subtask_data = fields.get("subtasks", [])
        for subtask in subtask_data:
            subtask_key = subtask.get("key")
            if subtask_key:
                subtasks.append(subtask_key)
        
        # Extract issue links
        issue_links = []
        links_data = fields.get("issuelinks", [])
        for link in links_data:
            link_type = link.get("type", {})
            link_type_name = link_type.get("name", "unknown")
            
            # Handle inward links
            inward_issue = link.get("inwardIssue")
            if inward_issue:
                issue_links.append(IssueLink(
                    issue_key=inward_issue.get("key"),
                    link_type=link_type_name,
                    direction="inward",
                    relationship=link_type.get("inward", "related")
                ))
            
            # Handle outward links
            outward_issue = link.get("outwardIssue")
            if outward_issue:
                issue_links.append(IssueLink(
                    issue_key=outward_issue.get("key"),
                    link_type=link_type_name,
                    direction="outward",
                    relationship=link_type.get("outward", "related")
                ))
        
        # Count remote links
        remote_links = self._client.get_remote_links(issue_key)
        remote_links_count = len(remote_links)
        
        return IssueRelationships(
            issue_key=issue_key,
            parent=parent,
            subtasks=subtasks,
            issue_links=issue_links,
            remote_links_count=remote_links_count
        )


    async def get_children(self, issue_key: str, include_parent_links: bool = True,
                          parent_link_field: str = "Parent Link") -> List[IssueSummary]:
        """Get direct children of an issue (subtasks and optionally parent-link children)."""
        children = []
        
        try:
            # Get the issue to extract subtasks
            issue_data = self._client.get_issue(issue_key)
            fields = issue_data.get("fields", {})
            
            # Add subtasks (these are always included as they're standard JIRA relationships)
            subtasks = fields.get("subtasks", [])
            for subtask in subtasks:
                subtask_key = subtask.get("key")
                if subtask_key:
                    subtask_fields = subtask.get("fields", {})
                    children.append(IssueSummary(
                        key=subtask_key,
                        summary=subtask_fields.get("summary", ""),
                        status=subtask_fields.get("status", {}).get("name", ""),
                        url=f"{self._client.base_url}/browse/{subtask_key}"
                    ))
            
            # Add parent-link children if requested
            if include_parent_links:
                try:
                    parent_link_children = self._client.get_parent_link_children(issue_key, parent_link_field)
                    self._logger.debug(f"Found {len(parent_link_children)} parent-link children for {issue_key}")
                    
                    for child_key in parent_link_children:
                        # Fetch details for each child
                        try:
                            child_data = self._client.get_issue(child_key)
                            child_fields = child_data.get("fields", {})
                            children.append(IssueSummary(
                                key=child_key,
                                summary=child_fields.get("summary", ""),
                                status=child_fields.get("status", {}).get("name", ""),
                                url=f"{self._client.base_url}/browse/{child_key}"
                            ))
                        except Exception as e:
                            self._logger.warning(f"Could not fetch details for parent-link child {child_key}: {e}")
                            continue
                            
                except Exception as e:
                    self._logger.warning(f"Could not search for parent-link children using field '{parent_link_field}': {e}")
                    # Continue without parent-link children rather than failing completely
        
        except Exception as e:
            self._logger.error(f"Failed to get children for issue {issue_key}: {e}")
            raise
        
        return children

    async def get_linked_issues(self, issue_key: str, link_type: Optional[str] = None) -> List[IssueLink]:
        """Get issues linked to the specified issue via JIRA issue links."""
        issue_data = self._client.get_issue(issue_key, expand="issuelinks")
        fields = issue_data.get("fields", {})
        
        issue_links = []
        links_data = fields.get("issuelinks", [])
        
        for link in links_data:
            link_type_data = link.get("type", {})
            link_type_name = link_type_data.get("name", "unknown")
            
            # Skip if filtering by link type and this doesn't match
            if link_type and link_type_name.lower() != link_type.lower():
                continue
            
            # Handle inward links
            inward_issue = link.get("inwardIssue")
            if inward_issue:
                issue_links.append(IssueLink(
                    issue_key=inward_issue.get("key"),
                    link_type=link_type_name,
                    direction="inward",
                    relationship=link_type_data.get("inward", "related")
                ))
            
            # Handle outward links
            outward_issue = link.get("outwardIssue")
            if outward_issue:
                issue_links.append(IssueLink(
                    issue_key=outward_issue.get("key"),
                    link_type=link_type_name,
                    direction="outward",
                    relationship=link_type_data.get("outward", "related")
                ))
        
        return issue_links

    async def get_parent(self, issue_key: str, include_parent_links: bool = True,
                        parent_link_field: str = "Parent Link") -> ParentInfo:
        """Get the immediate parent of an issue using dynamic field discovery."""
        issue_data = self._client.get_issue(issue_key, expand="parent")
        fields = issue_data.get("fields", {})
        
        parent_key = None
        parent_summary = None
        parent_type = None
        
        # Check for subtask parent first
        parent = fields.get("parent")
        if parent:
            parent_key = parent.get("key")
            parent_summary = parent.get("fields", {}).get("summary", "")
            parent_type = "subtask"
        
        # Check for custom parent link fields if no subtask parent found and enabled
        elif include_parent_links:
            # Extract project and issue type for field discovery
            project = fields.get("project", {}).get("key", "")
            issue_type = fields.get("issuetype", {}).get("name", "")
            
            if project and issue_type:
                # Get potential parent fields for this issue type
                parent_field_ids = self._get_parent_fields_for_issue(issue_key, project, issue_type)
                
                # Try each discovered parent field until we find one with a value
                for field_id in parent_field_ids:
                    parent_link = fields.get(field_id)
                    if parent_link:
                        parent_key = parent_link
                        parent_type = f"parent_field({field_id})"
                        
                        # Fetch parent summary
                        try:
                            parent_data = self._client.get_issue(parent_key)
                            parent_summary = parent_data.get("fields", {}).get("summary", "")
                        except Exception as e:
                            self._logger.warning(f"Could not fetch parent {parent_key} details: {e}")
                        
                        break  # Found a parent, stop looking
                
            # Fallback to old field name lookup if dynamic discovery failed or was skipped
            if not parent_key:
                self._logger.debug(f"Dynamic field discovery found no parent for {issue_key}, trying field name lookup")
                field_metadata = self._client.get_field_by_name(parent_link_field)
                if field_metadata:
                    field_id = field_metadata.get("id")
                    if field_id:
                        parent_link = fields.get(field_id)
                        if parent_link:
                            parent_key = parent_link
                            parent_type = f"parent_link({parent_link_field})"
                            
                            # Fetch parent summary
                            try:
                                parent_data = self._client.get_issue(parent_key)
                                parent_summary = parent_data.get("fields", {}).get("summary", "")
                            except Exception as e:
                                self._logger.warning(f"Could not fetch parent {parent_key} details: {e}")
        
        return ParentInfo(
            issue_key=issue_key,
            parent_key=parent_key,
            parent_summary=parent_summary,
            parent_type=parent_type
        )

    async def get_ancestors(self, issue_key: str, max_depth: int = 5,
                           include_parent_links: bool = True,
                           parent_link_field: str = "Parent Link") -> AncestorTree:
        """Get all ancestors of an issue by following parent relationships recursively."""
        ancestors = []
        traversal_order = []
        visited = set()
        current_key = issue_key
        current_depth = 0
        
        while current_key and current_key not in visited and (max_depth == -1 or current_depth < max_depth):
            visited.add(current_key)
            
            # Get parent of current issue
            parent_info = await self.get_parent(current_key, include_parent_links, parent_link_field)
            
            if parent_info.parent_key:
                # Check if parent is already visited (cycle detection)
                if parent_info.parent_key in visited:
                    self._logger.debug(f"Cycle detected: {parent_info.parent_key} already visited")
                    break
                
                # Fetch full parent details
                try:
                    parent_data = self._client.get_issue(parent_info.parent_key)
                    parent_fields = parent_data.get("fields", {})
                    
                    ancestor_summary = IssueSummary(
                        key=parent_info.parent_key,
                        summary=parent_fields.get("summary", ""),
                        status=parent_fields.get("status", {}).get("name", ""),
                        url=f"{self._client.base_url}/browse/{parent_info.parent_key}"
                    )
                    
                    ancestors.append(ancestor_summary)
                    traversal_order.append({
                        "issue_key": parent_info.parent_key,
                        "depth": current_depth,
                        "parent_type": parent_info.parent_type
                    })
                    
                    # Move to parent for next iteration
                    current_key = parent_info.parent_key
                    current_depth += 1
                    
                except Exception as e:
                    self._logger.warning(f"Could not fetch ancestor {parent_info.parent_key}: {e}")
                    break
            else:
                # No parent found, stop traversal
                break
        
        return AncestorTree(
            root_issue=issue_key,
            max_depth=max_depth,
            total_ancestors=len(ancestors),
            ancestors=ancestors,
            traversal_order=traversal_order
        )


###############################################################################
# Server factory                                                               #
###############################################################################

def create_server(
    *,
    url: str,
    username: Optional[str] = None,
    password: Optional[str] = None,
    token: Optional[str] = None,
    bearer_token: Optional[str] = None,
    field_cache_ttl: int = DEFAULT_FIELD_CACHE_TTL,
) -> FastMCP:
    """Create and configure a FastMCP server instance."""

    logging.basicConfig(level=logging.INFO)

    client = JiraClient(
        base_url=url,
        username=username,
        password=password,
        token=token,
        bearer_token=bearer_token,
    )

    mcp = FastMCP(
        name="JIRA Read-Only MCP Server",
        instructions=(
            "You are a JIRA expert assistant with comprehensive read-only access to JIRA data. "
            "WORKFLOW GUIDANCE: "
            "1. START with search_issues() to find relevant issues by project, status, or content "
            "2. Use get_issue() for detailed information about specific issues "
            "3. EXPLORE RELATIONSHIPS with: "
            "   - get_issue_relationships() for relationship overview "
            "   - get_descendants() for impact analysis (what depends on this?) "
            "   - get_ancestors() for context (what is this part of?) "
            "   - get_children() for immediate children only "
            "   - get_parent() for immediate parent only "
            "   - get_linked_issues() for horizontal relationships (blocks, depends) "
            "4. Use identifier_hint() when users provide invalid issue keys "
            "CHOOSE TOOLS WISELY: Use specific relationship tools based on user needs rather than always using the broadest option."
        ),
    )

    tools = JiraTools(client, field_cache_ttl)

    # ------------------------------------------------------------------
    # Register tools                                                    #
    # ------------------------------------------------------------------

    @mcp.tool(
        name="search_issues",
        description=(
            "Search JIRA for issues using JQL queries or simple text. Use this as your starting point "
            "to find issues by project, status, assignee, text content, or any JIRA field. "
            "Automatically detects JQL (if contains =, AND, OR) vs simple text search. "
            "Returns basic issue info - use get_issue() for full details of specific issues. "
            "Example: 'project = PROJ AND status = Open' or 'authentication bug'"
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=False,
        ),
    )
    async def search_issues_tool(query: str, max_results: int = 25) -> List[IssueSummary]:
        return await tools.search_issues(query, max_results)

    @mcp.tool(
        name="get_issue",
        description=(
            "Get comprehensive details for a specific JIRA issue including description, fields, "
            "status, assignee, and full raw data. Use this after search_issues() to get complete "
            "information about specific issues you've identified. The 'expand' parameter can "
            "include additional data like 'changelog,comments,attachments'."
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=False,
        ),
    )
    async def get_issue_tool(key: str, expand: Optional[str] = None) -> IssueDetails:
        return await tools.get_issue(key, expand)

    @mcp.tool(
        name="identifier_hint",
        description=(
            "Get help with JIRA issue key format (PROJECT-NUMBER pattern like PROJ-123). "
            "Use this when users provide invalid issue keys or need guidance on the expected format. "
            "Useful for explaining JIRA issue identifier structure to users."
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=False,
        ),
    )
    async def identifier_hint_tool() -> str:
        return await tools.identifier_hint()

    @mcp.tool(
        name="get_issue_relationships",
        description=(
            "Get a comprehensive overview of all relationships for an issue: parent, subtasks, "
            "issue links (blocks/depends), and remote links. Use this for a quick relationship "
            "summary before diving deeper with get_children(), get_parent(), or get_descendants(). "
            "Ideal for understanding an issue's context within the project hierarchy."
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=False,
        ),
    )
    async def get_issue_relationships_tool(issue_key: str) -> IssueRelationships:
        return await tools.get_issue_relationships(issue_key)


    @mcp.tool(
        name="get_children",
        description=(
            "Get immediate children only (1 level down) - includes both standard JIRA subtasks "
            "and custom parent-link field children by default. Use this to find direct child issues "
            "without traversing the full hierarchy. Commonly used for Epic→Story or Story→Task relationships. "
            "Set include_parent_links=False to only get standard subtasks."
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=False,
        ),
    )
    async def get_children_tool(
        issue_key: str,
        include_parent_links: bool = True,
        parent_link_field: str = "Parent Link"
    ) -> List[IssueSummary]:
        return await tools.get_children(issue_key, include_parent_links, parent_link_field)

    @mcp.tool(
        name="get_linked_issues",
        description=(
            "Get horizontally linked issues (blocks, depends on, relates to, etc.) without "
            "hierarchy traversal. Use for finding related work at the same level, dependencies, "
            "or blocking relationships. Filter by link_type (e.g., 'blocks', 'depends') to focus "
            "on specific relationship types. Different from parent/child relationships."
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=False,
        ),
    )
    async def get_linked_issues_tool(issue_key: str, link_type: Optional[str] = None) -> List[IssueLink]:
        return await tools.get_linked_issues(issue_key, link_type)

    @mcp.tool(
        name="get_parent",
        description=(
            "Get the immediate parent issue (1 level up) through subtask or custom parent-link "
            "relationships. Use to find what Epic contains this Story, or what Story contains "
            "this Task. Returns None if no parent exists. For full parent chain, use get_ancestors(). "
            "Handles both standard JIRA subtasks and custom Epic Link fields."
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=False,
        ),
    )
    async def get_parent_tool(
        issue_key: str,
        include_parent_links: bool = True,
        parent_link_field: str = "Parent Link"
    ) -> ParentInfo:
        return await tools.get_parent(issue_key, include_parent_links, parent_link_field)

    @mcp.tool(
        name="get_ancestors",
        description=(
            "Traverse UP the issue hierarchy to find all parent issues, grandparents, etc. "
            "Follows parent relationships to the root of the hierarchy. Use for understanding "
            "the full context: 'What Epic/Initiative does this task belong to?' "
            "Default depth=5 levels (ancestors are usually linear chains). Use max_depth=-1 "
            "for unlimited traversal."
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=False,
        ),
    )
    async def get_ancestors_tool(
        issue_key: str,
        max_depth: int = 5,
        include_parent_links: bool = True,
        parent_link_field: str = "Parent Link"
    ) -> AncestorTree:
        return await tools.get_ancestors(issue_key, max_depth, include_parent_links, parent_link_field)

    return mcp


###############################################################################
# CLI entry-point                                                             #
###############################################################################

async def _async_main() -> None:
    """Entry-point that loads configuration then starts the server."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Run the JIRA MCP server (stdio transport). Arguments override config file values.",
        add_help=True,
    )
    parser.add_argument(
        "-c",
        "--config",
        help="Path to YAML/JSON configuration file (default: mcp_jira_server.yaml).",
        default=None,
    )
    parser.add_argument("--url", help="JIRA base URL")
    parser.add_argument("--username", help="JIRA username (for password/token auth)")
    parser.add_argument("--password", help="JIRA password (basic auth)")
    parser.add_argument("--token", help="JIRA API token (basic auth)")
    parser.add_argument("--bearer-token", help="Personal Access Token (Bearer auth)")

    args = parser.parse_args()

    cfg = load_config(args.config)

    # Use CLI arguments to override any config-file values
    url = args.url or cfg.get("url")
    username = args.username or cfg.get("username")
    password = args.password or cfg.get("password")
    token = args.token or cfg.get("token")
    bearer_token = args.bearer_token or cfg.get("bearer_token")
    field_cache_ttl = cfg.get("field_cache_ttl", DEFAULT_FIELD_CACHE_TTL)  # Default: 1 hour

    if not url:
        raise ConfigError(
            "JIRA 'url' must be provided either via configuration file or --url argument."
        )

    server = create_server(
        url=url,
        username=username,
        password=password,
        token=token,
        bearer_token=bearer_token,
        field_cache_ttl=field_cache_ttl,
    )

    await server.run_async()  # Use the async version


def main() -> None:  # pragma: no cover
    """Synchronous wrapper for CLI entry-point."""
    import asyncio
    try:
        server = None
        
        # Parse args and create server synchronously
        import argparse
        parser = argparse.ArgumentParser(
            description="Run the JIRA MCP server (stdio transport). Arguments override config file values.",
            add_help=True,
        )
        parser.add_argument(
            "-c",
            "--config",
            help="Path to YAML/JSON configuration file (default: mcp_jira_server.yaml).",
            default=None,
        )
        parser.add_argument("--url", help="JIRA base URL")
        parser.add_argument("--username", help="JIRA username (for password/token auth)")
        parser.add_argument("--password", help="JIRA password (basic auth)")
        parser.add_argument("--token", help="JIRA API token (basic auth)")
        parser.add_argument("--bearer-token", help="Personal Access Token (Bearer auth)")

        args = parser.parse_args()

        cfg = load_config(args.config)

        # Use CLI arguments to override any config-file values
        url = args.url or cfg.get("url")
        username = args.username or cfg.get("username")
        password = args.password or cfg.get("password")
        token = args.token or cfg.get("token")
        bearer_token = args.bearer_token or cfg.get("bearer_token")
        field_cache_ttl = cfg.get("field_cache_ttl", DEFAULT_FIELD_CACHE_TTL)  # Default: 1 hour

        if not url:
            raise ConfigError(
                "JIRA 'url' must be provided either via configuration file or --url argument."
            )

        server = create_server(
            url=url,
            username=username,
            password=password,
            token=token,
            bearer_token=bearer_token,
            field_cache_ttl=field_cache_ttl,
        )

        # Run synchronously
        server.run()  # Use the sync version
        
    except KeyboardInterrupt:
        pass


if __name__ == "__main__":  # pragma: no cover
    main() 