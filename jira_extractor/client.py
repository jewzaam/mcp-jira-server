#!/usr/bin/env python3
# Generated by: Cursor (Claude)
"""
JIRA Client - REST API client for JIRA interactions
"""

import logging
from urllib.parse import urljoin
from typing import Optional, Dict, Any, Set, List

import requests
from requests.auth import HTTPBasicAuth


class JiraClient:
    """JIRA API client for extracting issues and relationships"""

    def __init__(self, base_url: str, username: Optional[str] = None, password: Optional[str] = None,
                 token: Optional[str] = None, bearer_token: Optional[str] = None):
        """
        Initialize JIRA client

        Args:
            base_url: JIRA instance URL
            username: Username for Basic Auth (used with password or token)
            password: Password for Basic Auth
            token: API token for Basic Auth (used with username)
            bearer_token: Personal Access Token for Bearer Auth

        Raises:
            ValueError: If authentication parameters are invalid
        """
        self.base_url = base_url.rstrip('/')
        self.api_base = urljoin(self.base_url, '/rest/api/2/')
        self.session = requests.Session()
        self._field_cache = {}  # Cache for field metadata lookups

        # Set up authentication
        self._setup_auth(username, password, token, bearer_token)

        # Set common headers
        self.session.headers.update({
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        })

    def _setup_auth(self, username: Optional[str] = None, password: Optional[str] = None,
                    token: Optional[str] = None, bearer_token: Optional[str] = None):
        """Setup authentication for the session"""
        if username and password:
            self.session.auth = HTTPBasicAuth(username, password)
        elif username and token:
            # For API token, use token as password with basic auth
            self.session.auth = HTTPBasicAuth(username, token)
        elif bearer_token:
            # For Bearer token (Personal Access Token), use Authorization header
            self.session.headers.update({'Authorization': f'Bearer {bearer_token}'})
        elif not username:
            # No authentication - for public issues
            pass
        else:
            raise ValueError("Authentication parameters are invalid.")

    def _make_api_request(self, url: str, params: Optional[Dict[str, Any]] = None,
                          resource_name: str = "resource",
                          handle_404_as_empty: bool = False) -> Any:
        """
        Make an API request with centralized error handling

        Args:
            url: API endpoint URL
            params: Query parameters
            resource_name: Name of resource for error messages
            handle_404_as_empty: If True, return empty list for 404 errors

        Returns:
            JSON response data or empty list for 404 when handle_404_as_empty=True

        Raises:
            Exception: For authentication, permission, or HTTP errors
        """
        logging.debug(f"Making API request to: {url}")
        if params:
            logging.debug(f"Query parameters: {params}")

        response = self.session.get(url, params=params or {})

        # Log response details for debugging
        logging.debug(f"Response status: {response.status_code}")
        try:
            logging.debug(f"Response headers: {dict(response.headers)}")
        except (TypeError, AttributeError):
            # Handle case where headers might be a Mock in tests
            logging.debug(f"Response headers: {response.headers}")

        # Handle common error cases
        if response.status_code == 401:
            raise Exception("Authentication failed. Please check your credentials.")
        elif response.status_code == 403:
            raise Exception(f"Access denied to {resource_name}. Check permissions.")
        elif response.status_code == 404:
            if handle_404_as_empty:
                return []
            else:
                raise Exception(f"{resource_name} not found.")

        # Handle any other HTTP errors
        response.raise_for_status()

        return response.json()

    def get_issue(self, issue_key: str, expand: Optional[str] = None) -> Dict[str, Any]:
        """
        Fetch a single JIRA issue

        Args:
            issue_key: JIRA issue key (e.g., 'RFE-7877')
            expand: Comma-separated list of fields to expand

        Returns:
            Issue data as dictionary

        Raises:
            Exception: If API request fails
        """
        url = urljoin(self.api_base, f'issue/{issue_key}')
        params = {}
        if expand:
            params['expand'] = expand

        return self._make_api_request(
            url,
            params=params if params else None,
            resource_name=f"Issue {issue_key}"
        )

    def test_connection(self) -> Dict[str, Any]:
        """Test JIRA connection and authentication"""
        url = urljoin(self.api_base, 'myself')
        return self._make_api_request(url, resource_name="User information")

    def get_remote_links(self, issue_key: str) -> List[Dict[str, Any]]:
        """
        Fetch remote links for a JIRA issue

        Args:
            issue_key: JIRA issue key (e.g., 'RFE-7877')

        Returns:
            List of remote link data

        Raises:
            Exception: If API request fails
        """
        url = urljoin(self.api_base, f'issue/{issue_key}/remotelink')

        return self._make_api_request(
            url,
            resource_name=f"remote links for issue {issue_key}",
            handle_404_as_empty=True
        )

    def get_parent_link_children(self, issue_key: str, parent_link_field: str = "Parent Link") -> List[str]:
        """
        Search for issues that have the given issue as their parent using a parent link field

        Args:
            issue_key: JIRA issue key to search for children
            parent_link_field: Name of the parent link field (default: "Parent Link")

        Returns:
            List of child issue keys

        Raises:
            Exception: If API request fails
        """
        url = urljoin(self.api_base, 'search')
        # Search using JQL for issues where the parent link field equals the given issue key
        jql = f'"{parent_link_field}" = "{issue_key}"'
        params = {
            'jql': jql,
            'fields': 'key',  # Only need the key field
            'maxResults': 1000  # Reasonable limit for children
        }

        try:
            response = self._make_api_request(
                url,
                params=params,
                resource_name=f"children of issue {issue_key} via {parent_link_field}",
                handle_404_as_empty=True
            )

            # Extract issue keys from the response
            issues = response.get('issues', [])
            child_keys = [issue.get('key') for issue in issues if issue.get('key')]
            logging.debug(f"Found {len(child_keys)} children via {parent_link_field} for {issue_key}: {child_keys}")
            return child_keys

        except Exception as e:
            logging.debug(f"Could not search for {parent_link_field} children of {issue_key}: {e}")
            return []

    def get_field_by_name(self, field_name: str) -> Optional[Dict[str, Any]]:
        """
        Look up field metadata by name to get field ID

        Args:
            field_name: Display name of the field (e.g., "Parent Link")

        Returns:
            Field metadata dictionary or None if not found

        Raises:
            Exception: If API request fails
        """
        # Check cache first
        if field_name in self._field_cache:
            return self._field_cache[field_name]

        url = urljoin(self.api_base, 'field')

        try:
            fields = self._make_api_request(url, resource_name="field metadata")

            # Find field by name
            for field in fields:
                if field.get('name') == field_name:
                    self._field_cache[field_name] = field
                    logging.debug(f"Found field '{field_name}' with ID: {field.get('id')}")
                    return field

            # Field not found
            logging.debug(f"Field '{field_name}' not found")
            self._field_cache[field_name] = None
            return None

        except Exception as e:
            logging.debug(f"Could not fetch field metadata: {e}")
            return None

    def get_descendants(self, issue_key: str, depth: int = 0,
                        include_subtasks: bool = False, include_links: bool = False,
                        include_remote_links: bool = False, include_parent_links: bool = False,
                        parent_link_field: str = "Parent Link", expand: Optional[str] = None) -> Dict[str, Dict[str, Any]]:
        """
        Fetch an issue and its descendants based on specified relationship types and depth

        Args:
            issue_key: Starting JIRA issue key
            depth: Maximum traversal depth (-1 for unlimited, 0 for issue only)
            include_subtasks: Include subtask relationships
            include_links: Include issue links
            include_remote_links: Include remote links
            include_parent_links: Include parent link custom field relationships
            parent_link_field: Name of the parent link field (default: "Parent Link")
            expand: Comma-separated fields to expand for each issue

        Returns:
            Dictionary mapping issue keys to issue data

        Raises:
            Exception: If traversal encounters errors
        """
        issues = {}  # Dict[str, Dict[str, Any]]
        visited = set()  # Set[str]
        to_process = [(issue_key, 0)]  # List[(str, int)] - (issue_key, current_depth)

        extraction_metadata = {
            "start_issue": issue_key,
            "max_depth": depth,
            "include_subtasks": include_subtasks,
            "include_links": include_links,
            "include_remote_links": include_remote_links,
            "include_parent_links": include_parent_links,
            "parent_link_field": parent_link_field,
            "traversal_order": []
        }

        while to_process:
            current_key, current_depth = to_process.pop(0)

            # Skip if already processed
            if current_key in visited:
                continue

            visited.add(current_key)
            extraction_metadata["traversal_order"].append({
                "issue_key": current_key,
                "depth": current_depth
            })

            logging.info(f"Processing issue {current_key} at depth {current_depth}")

            try:
                # Fetch the issue
                issue_data = self.get_issue(current_key, expand=expand)
                issues[current_key] = issue_data

                # Stop traversing deeper if we've reached the depth limit
                if depth != -1 and current_depth >= depth:
                    continue

                # Collect related issues to process next
                related_issues = self._get_related_issue_keys(
                    issue_data, current_key, include_subtasks, include_links, include_remote_links, include_parent_links, parent_link_field
                )

                # Add related issues to processing queue
                for related_key in related_issues:
                    if related_key not in visited:
                        to_process.append((related_key, current_depth + 1))

            except Exception as e:
                logging.warning(f"Failed to process issue {current_key}: {e}")
                # Continue processing other issues
                continue

        # Store extraction metadata in the result
        issues["_extraction_metadata"] = extraction_metadata

        return issues

    def _get_related_issue_keys(self, issue_data: Dict[str, Any], current_key: str,
                                include_subtasks: bool, include_links: bool,
                                include_remote_links: bool, include_parent_links: bool,
                                parent_link_field: str) -> Set[str]:
        """
        Extract related issue keys from issue data based on relationship types

        Args:
            issue_data: Issue data from JIRA API
            current_key: Current issue key (for logging)
            include_subtasks: Include subtask relationships
            include_links: Include issue links
            include_remote_links: Include remote links
            include_parent_links: Include parent link custom field relationships
            parent_link_field: Name of the parent link field

        Returns:
            Set of related issue keys
        """
        related_keys = set()
        fields = issue_data.get('fields', {})

        # Process subtasks
        if include_subtasks:
            # Get subtasks (children)
            subtasks = fields.get('subtasks', [])
            for subtask in subtasks:
                subtask_key = subtask.get('key')
                if subtask_key:
                    related_keys.add(subtask_key)
                    logging.debug(f"Found subtask: {subtask_key}")

            # Get parent issue
            parent = fields.get('parent')
            if parent:
                parent_key = parent.get('key')
                if parent_key:
                    related_keys.add(parent_key)
                    logging.debug(f"Found parent: {parent_key}")

        # Process issue links
        if include_links:
            issue_links = fields.get('issuelinks', [])
            for link in issue_links:
                # Links can have inwardIssue or outwardIssue
                inward_issue = link.get('inwardIssue')
                if inward_issue:
                    inward_key = inward_issue.get('key')
                    if inward_key:
                        related_keys.add(inward_key)
                        link_type = link.get('type', {}).get('inward', 'related')
                        logging.debug(f"Found inward link ({link_type}): {inward_key}")

                outward_issue = link.get('outwardIssue')
                if outward_issue:
                    outward_key = outward_issue.get('key')
                    if outward_key:
                        related_keys.add(outward_key)
                        link_type = link.get('type', {}).get('outward', 'related')
                        logging.debug(f"Found outward link ({link_type}): {outward_key}")

        # Process remote links (these don't lead to other JIRA issues, but we can fetch them for completeness)
        if include_remote_links:
            try:
                remote_links = self.get_remote_links(current_key)
                logging.debug(f"Found {len(remote_links)} remote links for {current_key}")
                # Note: Remote links don't contribute to related_keys since they're external
            except Exception as e:
                logging.debug(f"Could not fetch remote links for {current_key}: {e}")

        # Process parent links (custom field)
        if include_parent_links:
            # Look up the field metadata to get the field ID
            field_metadata = self.get_field_by_name(parent_link_field)
            if field_metadata:
                field_id = field_metadata.get('id')
                if field_id:
                    # Get parent from the custom field
                    parent_link = fields.get(field_id)
                    if parent_link:
                        related_keys.add(parent_link)
                        logging.debug(f"Found parent link via {parent_link_field}: {parent_link}")

            # Search for children that have this issue as their parent
            try:
                children = self.get_parent_link_children(current_key, parent_link_field)
                for child_key in children:
                    related_keys.add(child_key)
                    logging.debug(f"Found parent link child: {child_key}")
            except Exception as e:
                logging.debug(f"Could not fetch parent link children for {current_key}: {e}")

        return related_keys